"""
ProofPilot branded .docx generator
Takes completed job content and produces a formatted Word document
with ProofPilot brand colors, clean typography, and proper structure.

Supports markdown tables: | Col | Col | syntax renders as branded Word tables.
"""

import os
import re
from pathlib import Path
from datetime import datetime

from docx import Document
from docx.shared import Pt, RGBColor, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml.ns import qn
from docx.oxml import OxmlElement

# ── ProofPilot brand colors ────────────────────────────────
DARK_BLUE  = RGBColor(0x00, 0x18, 0x4D)   # #00184D
ELEC_BLUE  = RGBColor(0x00, 0x51, 0xFF)   # #0051FF
NEON_GREEN = RGBColor(0xC8, 0xFF, 0x00)   # #C8FF00
MID_GRAY   = RGBColor(0x66, 0x66, 0x88)   # subdued text
LIGHT_GRAY = RGBColor(0xAA, 0xAA, 0xBB)   # footer / dividers
WHITE      = RGBColor(0xFF, 0xFF, 0xFF)
LIGHT_ROW  = RGBColor(0xF5, 0xF7, 0xFF)   # light blue-white for alternating rows

BODY_FONT = "Calibri"
DISPLAY_FONT = "Calibri"  # swap to "Bebas Neue" if installed on the server

# DOCS_DIR env var lets Railway Volume mount survive restarts.
# Default: ./temp_docs (relative to wherever the process runs)
TEMP_DIR = Path(os.environ.get("DOCS_DIR", str(Path(__file__).parent.parent / "temp_docs")))


def generate_docx(job_id: str, job_data: dict) -> Path:
    """Generate a branded ProofPilot .docx and return its path."""
    TEMP_DIR.mkdir(exist_ok=True)

    content        = job_data["content"]
    client_name    = job_data["client_name"]
    workflow_title = job_data["workflow_title"]

    doc = Document()
    _set_margins(doc)
    _add_header_block(doc, client_name, workflow_title)
    _render_markdown(doc, content)
    _add_footer_block(doc, client_name)

    out_path = TEMP_DIR / f"{job_id}.docx"
    doc.save(out_path)
    return out_path


# ── Document sections ──────────────────────────────────────

def _set_margins(doc: Document) -> None:
    for section in doc.sections:
        section.top_margin    = Inches(0.9)
        section.bottom_margin = Inches(0.9)
        section.left_margin   = Inches(1.1)
        section.right_margin  = Inches(1.1)


def _add_header_block(doc: Document, client_name: str, workflow_title: str) -> None:
    header = doc.add_paragraph()
    header.alignment = WD_ALIGN_PARAGRAPH.LEFT

    brand = header.add_run("PROOFPILOT")
    brand.bold = True
    brand.font.size = Pt(13)
    brand.font.color.rgb = DARK_BLUE
    brand.font.name = DISPLAY_FONT

    sep = header.add_run("  ·  ")
    sep.font.size = Pt(11)
    sep.font.color.rgb = ELEC_BLUE
    sep.font.name = BODY_FONT

    wf = header.add_run(workflow_title)
    wf.font.size = Pt(11)
    wf.font.color.rgb = ELEC_BLUE
    wf.font.name = BODY_FONT

    sep2 = header.add_run("  ·  ")
    sep2.font.size = Pt(11)
    sep2.font.color.rgb = MID_GRAY
    sep2.font.name = BODY_FONT

    cli = header.add_run(client_name)
    cli.font.size = Pt(11)
    cli.font.color.rgb = MID_GRAY
    cli.font.name = BODY_FONT

    divider = doc.add_paragraph()
    d = divider.add_run("─" * 90)
    d.font.size = Pt(7)
    d.font.color.rgb = ELEC_BLUE

    spacer = doc.add_paragraph()
    spacer.space_after = Pt(4)


def _add_footer_block(doc: Document, client_name: str) -> None:
    doc.add_paragraph()
    divider = doc.add_paragraph()
    d = divider.add_run("─" * 90)
    d.font.size = Pt(7)
    d.font.color.rgb = LIGHT_GRAY

    footer = doc.add_paragraph()
    footer.alignment = WD_ALIGN_PARAGRAPH.CENTER
    f = footer.add_run(
        f"Generated by ProofPilot Agency Hub  ·  {client_name}  ·  {datetime.now().strftime('%B %d, %Y')}"
    )
    f.font.size = Pt(8)
    f.font.color.rgb = LIGHT_GRAY
    f.font.name = BODY_FONT


# ── Table helpers ──────────────────────────────────────────

def _set_cell_background(cell, rgb: RGBColor) -> None:
    """Set a table cell's background fill color."""
    tc = cell._tc
    tcPr = tc.get_or_add_tcPr()
    shd = OxmlElement("w:shd")
    hex_color = f"{rgb[0]:02X}{rgb[1]:02X}{rgb[2]:02X}"
    shd.set(qn("w:val"), "clear")
    shd.set(qn("w:color"), "auto")
    shd.set(qn("w:fill"), hex_color)
    tcPr.append(shd)


def _parse_table_lines(lines: list[str]) -> tuple[list[str], list[list[str]]]:
    """
    Parse markdown pipe table lines into headers + rows.
    Skips separator lines (|---|---|).
    Returns (headers, rows) where each is a list of cell text strings.
    """
    headers: list[str] = []
    rows: list[list[str]] = []

    for line in lines:
        stripped = line.strip()
        if not stripped.startswith("|"):
            continue
        # Skip separator rows like |---|---|
        if re.match(r"^\|[-:\s|]+\|$", stripped):
            continue
        # Parse cells: split on |, strip, drop empty edge elements
        cells = [c.strip() for c in stripped.split("|")]
        cells = [c for c in cells if c != "" or len(cells) > 2]
        # Remove leading/trailing empty cells from pipe syntax
        if cells and cells[0] == "":
            cells = cells[1:]
        if cells and cells[-1] == "":
            cells = cells[:-1]
        if not cells:
            continue
        if not headers:
            headers = cells
        else:
            rows.append(cells)

    return headers, rows


def _add_brand_table(doc: Document, headers: list[str], rows: list[list[str]]) -> None:
    """
    Add a ProofPilot-branded table to the document.
    - Header row: Dark Blue background, white bold text
    - Body rows: alternating white / light-blue-white
    - All cells: 10pt Calibri
    """
    if not headers:
        return

    num_cols = len(headers)
    num_rows = 1 + len(rows)
    table = doc.add_table(rows=num_rows, cols=num_cols)
    table.style = "Table Grid"

    # Style header row
    hdr_row = table.rows[0]
    for i, header_text in enumerate(headers):
        cell = hdr_row.cells[i]
        _set_cell_background(cell, DARK_BLUE)
        p = cell.paragraphs[0]
        # Clear existing runs
        for run in p.runs:
            run.text = ""
        # Strip markdown bold from header text
        clean = re.sub(r"\*\*([^*]+)\*\*", r"\1", header_text).strip()
        run = p.add_run(clean)
        run.bold = True
        run.font.size = Pt(10)
        run.font.color.rgb = WHITE
        run.font.name = BODY_FONT
        p.space_before = Pt(3)
        p.space_after = Pt(3)

    # Style body rows
    for row_idx, row_data in enumerate(rows):
        tbl_row = table.rows[row_idx + 1]
        bg_color = LIGHT_ROW if row_idx % 2 == 1 else WHITE

        for col_idx in range(num_cols):
            cell = tbl_row.cells[col_idx]
            _set_cell_background(cell, bg_color)
            p = cell.paragraphs[0]
            for run in p.runs:
                run.text = ""
            cell_text = row_data[col_idx] if col_idx < len(row_data) else ""
            _inline_format_table(p, cell_text)
            p.space_before = Pt(2)
            p.space_after = Pt(2)

    # Spacing after table
    spacer = doc.add_paragraph()
    spacer.space_after = Pt(6)


def _inline_format_table(paragraph, text: str) -> None:
    """Inline formatting for table cells — bold/italic/plain, 10pt."""
    bold_parts = re.split(r"(\*\*[^*]+\*\*)", text)
    for part in bold_parts:
        if part.startswith("**") and part.endswith("**") and len(part) > 4:
            r = paragraph.add_run(part[2:-2])
            r.bold = True
            r.font.name = BODY_FONT
            r.font.size = Pt(10)
        else:
            italic_parts = re.split(r"(\*[^*]+\*)", part)
            for sub in italic_parts:
                if sub.startswith("*") and sub.endswith("*") and len(sub) > 2:
                    r = paragraph.add_run(sub[1:-1])
                    r.italic = True
                    r.font.name = BODY_FONT
                    r.font.size = Pt(10)
                else:
                    r = paragraph.add_run(sub)
                    r.font.name = BODY_FONT
                    r.font.size = Pt(10)


# ── Markdown renderer ──────────────────────────────────────

def _render_markdown(doc: Document, content: str) -> None:
    lines = content.split("\n")
    i = 0
    prev_empty = False

    while i < len(lines):
        line = lines[i]

        # Skip workflow status lines ("> Pulling...", "> Fetching...")
        if line.strip().startswith("> "):
            i += 1
            continue

        # ── Markdown table detection ──────────────────────
        # A table starts with a | character and continues until a non-| line
        if line.strip().startswith("|") and not re.match(r"^\|[-:\s|]+\|$", line.strip()):
            table_lines = []
            while i < len(lines) and lines[i].strip().startswith("|"):
                table_lines.append(lines[i])
                i += 1
            headers, rows = _parse_table_lines(table_lines)
            if headers:
                _add_brand_table(doc, headers, rows)
            prev_empty = False
            continue

        # H1
        if line.startswith("# "):
            p = doc.add_paragraph()
            r = p.add_run(line[2:].strip())
            r.bold = True
            r.font.size = Pt(24)
            r.font.color.rgb = DARK_BLUE
            r.font.name = DISPLAY_FONT
            p.space_before = Pt(6)
            p.space_after  = Pt(10)
            prev_empty = False

        # H2
        elif line.startswith("## "):
            p = doc.add_paragraph()
            r = p.add_run(line[3:].strip())
            r.bold = True
            r.font.size = Pt(15)
            r.font.color.rgb = ELEC_BLUE
            r.font.name = DISPLAY_FONT
            p.space_before = Pt(14)
            p.space_after  = Pt(4)
            prev_empty = False

        # H3
        elif line.startswith("### "):
            p = doc.add_paragraph()
            r = p.add_run(line[4:].strip())
            r.bold = True
            r.font.size = Pt(12)
            r.font.color.rgb = DARK_BLUE
            r.font.name = BODY_FONT
            p.space_before = Pt(10)
            p.space_after  = Pt(3)
            prev_empty = False

        # Unordered bullet
        elif line.startswith("- ") or line.startswith("* "):
            p = doc.add_paragraph(style="List Bullet")
            p.paragraph_format.left_indent = Inches(0.25)
            _inline_format(p, line[2:].strip())
            p.space_after = Pt(3)
            prev_empty = False

        # Numbered list
        elif re.match(r"^\d+\.\s", line):
            p = doc.add_paragraph(style="List Number")
            p.paragraph_format.left_indent = Inches(0.25)
            _inline_format(p, re.sub(r"^\d+\.\s", "", line).strip())
            p.space_after = Pt(3)
            prev_empty = False

        # Horizontal rule / section divider (---)
        elif line.strip() == "---":
            p = doc.add_paragraph()
            p.space_before = Pt(8)
            p.space_after  = Pt(8)
            r = p.add_run("─" * 90)
            r.font.size = Pt(7)
            r.font.color.rgb = ELEC_BLUE
            prev_empty = False

        # Empty line — small paragraph break (avoid double-spacing)
        elif line.strip() == "":
            if not prev_empty:
                sp = doc.add_paragraph()
                sp.space_after = Pt(2)
            prev_empty = True
            i += 1
            continue

        # Body paragraph
        else:
            p = doc.add_paragraph()
            _inline_format(p, line.strip())
            p.space_after = Pt(6)
            prev_empty = False

        i += 1


def _inline_format(paragraph, text: str) -> None:
    """
    Handle inline markdown: **bold**, *italic*, and plain text.
    Splits on bold markers first, then italic within plain segments.
    """
    bold_parts = re.split(r"(\*\*[^*]+\*\*)", text)

    for part in bold_parts:
        if part.startswith("**") and part.endswith("**") and len(part) > 4:
            r = paragraph.add_run(part[2:-2])
            r.bold = True
            r.font.name = BODY_FONT
            r.font.size = Pt(11)
        else:
            italic_parts = re.split(r"(\*[^*]+\*)", part)
            for sub in italic_parts:
                if sub.startswith("*") and sub.endswith("*") and len(sub) > 2:
                    r = paragraph.add_run(sub[1:-1])
                    r.italic = True
                    r.font.name = BODY_FONT
                    r.font.size = Pt(11)
                else:
                    r = paragraph.add_run(sub)
                    r.font.name = BODY_FONT
                    r.font.size = Pt(11)
